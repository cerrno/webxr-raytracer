<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Virtual Reality Black Hole | Lucas V. Schuermann</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <style>
            body {
                margin: 0;
                background-color: #000;
                color: #fff;
                font-family: Monospace;
                font-size: 13px;
                line-height: 24px;
                overscroll-behavior: none;
            }

            a {
                color: #ff0;
                text-decoration: none;
            }

            a:hover {
                text-decoration: underline;
            }

            canvas {
                display: block;
            }

            #info {
                position: absolute;
                top: 0px;
                width: 100%;
                padding: 10px;
                box-sizing: border-box;
                text-align: center;
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
                pointer-events: none;
                z-index: 1; /* TODO Solve this in HTML */
            }

            a, button, input, select {
                pointer-events: auto;
            }

            .dg.ac {
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
                z-index: 2 !important; /* TODO Solve this in HTML */
            }
        </style>
    </head>
    <body>
        <script src="js/HelioWebXRPolyfill.js"></script>

        <div id="info">
            <a href="/index.html" target="_blank" rel="noopener">Lucas V. Schuermann</a> WebXR Virtual Reality - Schwarzchild Black Hole Simulation
        </div>

        <script id="vertex-shader" type="x-shader/x-vertex">
            precision mediump float;
            varying vec3 localSurfacePos;
            void main() {
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                localSurfacePos = position;
            }
        </script>

        <script id="fragment-shader" type="x-shader/x-fragment">
               precision mediump float;
      
      uniform float time;
      uniform vec3 localCameraPos;
      varying vec3 localSurfacePos;
      
      const float blobsize = 0.2;
      
      
      
      float smoothBlend( float a, float b, float k ){
          float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);
          return mix(b,a,h) - k*h*(1.0-h);
      }
      
      void hardAdd(inout float curD, float newD){
        curD = min(curD,newD);
      }
      void smoothAdd(inout float curD, float newD, float blendPower){
          curD = smoothBlend( newD, curD, blendPower );
      }
      
      
      float obj_ball(vec3 p, vec3 center, float radius){
          return length(p-center)-radius;
      }
      
      vec3 blobBallPos(float i){
          
          float v = time/1000.0*2.0 + i*100.0;
          return vec3(
            sin( v + sin(v*0.8) + sin(v*0.2)*sin(v*2.1) )*blobsize,
            sin( v + sin(v*0.6) + sin(v*0.4)*sin(v*2.2) )*blobsize,
            sin( v + sin(v*0.4) + sin(v*0.6)*sin(v*2.3) )*blobsize
          );
          
      }
      
      float room(vec3 p){
        
        float distance = 9999.9;
        
        hardAdd(distance, obj_ball(p, blobBallPos(0.0), blobsize) );
        for(float i=1.0; i<8.0; i+=1.0){
          smoothAdd(distance, obj_ball(p, blobBallPos(i), blobsize) , blobsize);
        }
        
        return distance;
        
      }
      
      
      void main() {
        
        
        vec3 curCameraRayUnit = normalize(localSurfacePos - localCameraPos);
        
        
        // zero optimization done to step size, max iterations, etc..!
        const vec3 e=vec3(0.02,0,0);
        const float maxd=40.0; //Max depth
        vec3 c,p,N;
        float sA,sP;
        
        // march to bg
        vec3 color=vec3(1.0,1.0,1.0);
        float f=0.0;
        float d=0.001;
        vec3 surfaceColor;
        for(int i=0;i<64;i++){
          if ((abs(d) < .001) || (f > maxd)) break;
          f+=d;
          p=localCameraPos+curCameraRayUnit*f;
          d = room(p);
        }
        
        float specA=1.0, specP=8.0;
        
        if (f < maxd){
          
          vec3 n = vec3(d-room(p-e.xyy),
                  d-room(p-e.yxy),
                  d-room(p-e.yyx));
          N = normalize(n);
          
          vec3 L = normalize(vec3(1.0,1.0,1.0)-p);
          
          float diffuse=max(dot(N,L),0.0);
          vec3 H = normalize(L-curCameraRayUnit);
          float specular = max(dot(H,N),0.0);
          color = (diffuse*0.8+0.2)*vec3(1.0,0,1.0) + pow(specular,specP)*specA;
          
        } else {
          
          discard;
          
        }
        
        gl_FragColor = vec4(color,1.0);
        
      }
        </script>

        <script type="module">
            import * as THREE from './js/three.module.js';
            import Stats from './js/stats.module.js';
            import {VRButton} from './js/VRButton.js';
            import {OrbitControls} from './js/OrbitControls.js';

            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType( 'local' );
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            const stats = new Stats();
            document.body.appendChild(stats.dom);

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
            const controls = new OrbitControls(camera, renderer.domElement);
            camera.position.set(0, 0, 0);
            controls.enablePan = false;
            controls.enableZoom = false;
            controls.update();

            /*
            const loader = new THREE.TextureLoader();
            const texture = loader.load('./stars.jpg');
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            */

            const vertexShader = document.getElementById('vertex-shader').textContent;
            const fragmentShader = document.getElementById('fragment-shader').textContent;
            const uniforms = {
                time:{value:0},
                localCameraPos:{value:new THREE.Vector3(0,0,0)}
            };
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms,
                side: THREE.BackSide,
            });

            var geometry = new THREE.BoxGeometry(5,5,5);
            const skybox = new THREE.Mesh(geometry, material);
            skybox.position.set(0.0,0.0,-1.0);
            scene.add(skybox);
            skybox.onBeforeRender = function(renderer,scene,camera,geometry,material,group){
                console.log(camera.matrixWorld.elements);
                uniforms.localCameraPos.value.setFromMatrixPosition(camera.matrixWorld);
                skybox.worldToLocal(uniforms.localCameraPos.value);
            };

            const onWindowResize = () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
            };
            window.addEventListener('resize', onWindowResize, false);

            renderer.setAnimationLoop((time) => {
                uniforms.time.value = time;

                // render
                renderer.render(scene, camera);
                stats.update();
            });
        </script>
    </body>
</html>