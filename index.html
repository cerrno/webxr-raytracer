<!DOCTYPE html>
<html lang="en">
    <head>
        <title>WebXR VR Raytracer | Lucas V. Schuermann</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <style>
            body {
                margin: 0;
                background-color: #000;
                color: #fff;
                font-family: Monospace;
                font-size: 13px;
                line-height: 24px;
                overscroll-behavior: none;
            }
            a {
                color: #FA0;
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            canvas {
                display: block;
            }
            #info {
                position: absolute;
                top: 0px;
                width: 100%;
                padding: 10px;
                box-sizing: border-box;
                text-align: center;
                user-select: none;
                pointer-events: none;
                z-index: 1;
            }
            a, button, input, select {
                pointer-events: auto;
            }
        </style>
    </head>
    <body>
        <div id="info">
            <a href="/index.html" target="_blank" rel="noopener">Lucas V. Schuermann</a> - WebXR VR Raytracer
        </div>
        <script type="module">
            import * as THREE from './js/three.module.js';
            import Stats from './js/stats.module.js';
            import {VRButton} from './js/VRButton.js';
            import {OrbitControls} from './js/OrbitControls.js';

            const SKYBOX_ORIGIN = [0,0,-3];
            
            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local');
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            const stats = new Stats();
            document.body.appendChild(stats.dom);

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x404040);
            const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            const controls = new OrbitControls(camera, renderer.domElement);
            camera.position.set(0,1.6,3);
            controls.target.set(...SKYBOX_ORIGIN);
            controls.update();

            const vertexShaderSource = document.getElementById('vertex-shader').textContent;
            const fragmentShaderSource = document.getElementById('fragment-shader').textContent;
            const uniforms = {
                time: { 
                    value: 0,
                },
                localCameraPos: {
                    value: new THREE.Vector3(0,0,0),
                },
            };
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShaderSource,
                fragmentShader: fragmentShaderSource,
                uniforms,
                side: THREE.BackSide,
            });
            
            var geometry = new THREE.BoxGeometry(500,500,500);
            const skybox = new THREE.Mesh(geometry, material);
            skybox.position.set(...SKYBOX_ORIGIN);
            scene.add(skybox);
            skybox.onBeforeRender = (renderer, scene, camera, geometry, material, group) => {
                uniforms.localCameraPos.value.setFromMatrixPosition(camera.matrixWorld);
                skybox.worldToLocal(uniforms.localCameraPos.value);
            };
            
            const onWindowResize = () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            };
            window.addEventListener('resize', onWindowResize, false);
            
            renderer.setAnimationLoop((time) => {
                uniforms.time.value = time;
                renderer.render(scene, camera);
                stats.update();
            });
        </script>
        <script id="vertex-shader" type="x-shader/x-vertex">
            precision mediump float;

            varying vec3 localSurfacePos;

            void main() {
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                localSurfacePos = position;
            }
        </script>
        <script id="fragment-shader" type="x-shader/x-fragment">
            precision mediump float;
            
            uniform float time;
            uniform vec3 localCameraPos;
            varying vec3 localSurfacePos;
            
            const float BLOBSIZE = 0.2;

            float smoothBlend( float a, float b, float k ){
                float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);
                return mix(b,a,h) - k*h*(1.0-h);
            }
            
            void hardAdd(inout float curD, float newD){
                curD = min(curD,newD);
            }

            void smoothAdd(inout float curD, float newD, float blendPower){
                curD = smoothBlend( newD, curD, blendPower );
            }
            
            float obj_ball(vec3 p, vec3 center, float radius){
                return length(p-center)-radius;
            }
            
            vec3 blobBallPos(float i){
                float v = time/1000.0*2.0 + i*100.0;
                return vec3(
                    sin(v + sin(v*0.8) + sin(v*0.2)*sin(v*2.1))*BLOBSIZE,
                    sin(v + sin(v*0.6) + sin(v*0.4)*sin(v*2.2))*BLOBSIZE,
                    sin(v + sin(v*0.4) + sin(v*0.6)*sin(v*2.3))*BLOBSIZE
                );
            }
            
            float room(vec3 p){
                float distance = 9999.9;
                hardAdd(distance, obj_ball(p, blobBallPos(0.0), BLOBSIZE) );
                for(float i=1.0; i<8.0; i+=1.0) {
                    smoothAdd(distance, obj_ball(p, blobBallPos(i), BLOBSIZE), BLOBSIZE);
                }
                return distance;
            }
            
            void main() {
                vec3 curCameraRayUnit = normalize(localSurfacePos - localCameraPos);
                
                // zero optimization done to step size, max iterations, etc..!
                const vec3 e=vec3(0.02,0,0);
                const float maxd=40.0; //Max depth
                vec3 c,p,N;
                float sA,sP;
                
                // march to bg
                vec3 color=vec3(1.0,1.0,1.0);
                float f=0.0;
                float d=0.001;
                vec3 surfaceColor;
                for(int i=0;i<64;i++){
                    if ((abs(d) < .001) || (f > maxd)) break;
                    f += d;
                    p = localCameraPos+curCameraRayUnit*f;
                    d = room(p);
                }
                
                float specA=1.0, specP=8.0;
                
                if (f < maxd){
                    vec3 n = vec3(d-room(p-e.xyy),
                                  d-room(p-e.yxy),
                                  d-room(p-e.yyx));
                    N = normalize(n);
                    
                    vec3 L = normalize(vec3(1.0,1.0,1.0)-p);
                    
                    float diffuse=max(dot(N,L),0.0);
                    vec3 H = normalize(L-curCameraRayUnit);
                    float specular = max(dot(H,N),0.0);
                    color = (diffuse*0.8+0.2)*vec3(1.0,0,1.0) + pow(specular,specP)*specA;
                    
                } else {
                    discard;
                }
                gl_FragColor = vec4(color,1.0);
            }
        </script>
    </body>
</html>